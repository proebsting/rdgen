<< from grammar import Production,Value,Alts,Sym,Opt,Rep,Parens,Lambda,Cons,Spec,Break,Expr,Continue,OnePlus,Sequence >>

%% spec.return = "Spec"
%% spec.preamble = "list[str]"
spec:
    { code }'preamble
    grammar'g
    = << Spec(preamble,g) >>
    .

%% grammar.return = "list[Production]"
%% grammar.prods = "list[Production]"
grammar:
    production'p 
    { production }'prods
    = << [p]+prods >> 
    .

%% production.return = "Production"
production: 
    id'lhs 
    ":" 
    alternation'rhs 
    "." 
    = << Production(lhs, rhs) >> 
    .

%% alternation.return = "Alts | Sequence"
%% alternation.seqs = "list[Sequence]"
alternation: 
    sequence'x 
    { "|" =sequence }'seqs
    =<< Alts([x]+seqs) if seqs else x >>
    .

%% sequence.return = "Sequence"
%% sequence.prologue = "list[str]"
sequence: 
    term't
    << ret = last = Cons(t, Lambda()) >>
    {
        term't              
        << last.cdr = Cons(t, last.cdr) >> 
        << last = last.cdr              >> 
    } !
    = << Sequence(ret) >> 
    .

%% term.return = "Expr"
%% term.stmts = "list[str]"
term: 
    [ "=" ]     'at 
    =base       't 
    [ "!" ]     'simple
    [ "'" =id ] 'name 
    << t.keep   = at is not None       >>
    << t.simple = simple is not None   >>
    << t.name   = name or None         >>
    .

%% base.return = "Expr"
%% base.code = "str"
base:
    "(" alternation'v ")"     =<< Parens(v)  >>
    | "{" alternation'v "}"   =<< Rep(v)     >>
    | "[" alternation'v "]"   =<< Opt(v)     >>
    | "{+" alternation'v "+}" =<< OnePlus(v) >>
    | id'id                   =<< Sym(id)    >>
    | str's                   =<< Sym(s)     >>
    | code                    =<< Value(code) >>
    | "break"                 =<< Break()    >>
    | "continue"              =<< Continue() >>
    .

code: CODE'c   =<< c.value.strip() >> .        %% code.return = "str"
id  : ID'id    =<< id.value        >> .        %% id.return  = "str"
str : STR'id   =<< id.value        >> .        %% str.return = "str"
